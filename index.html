<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Emily‚Äôs Cat</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      background:#f2f2f2;
      display:flex;
      flex-direction:column;         /* stack canvas then buttons */
      align-items:center;
      justify-content:center;
      gap:16px;                      /* space between canvas & buttons */
      font-family: system-ui, sans-serif;
    }
    canvas{
      image-rendering: pixelated;
      background:#fff;
      border:1px solid #ddd;
    }
    .button-row{
      display:flex;
      gap:20px;
      justify-content:center;
      align-items:center;
    }
    .btn{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 16px;
      font-size:18px;
      border:2px solid #333;
      background:#f2f2f2;
      border-radius:6px;
      cursor:pointer;
    }
    .btn:hover{ background:#e6e6e6; }
    .btn img{
      width:24px; height:24px; image-rendering: pixelated;
    }
  </style>
</head>
<body>

  <!-- canvas (we‚Äôll scale it so pixels stay chunky) -->
  <canvas id="game" width="128" height="128"></canvas>

  <!-- buttons -->
  <div class="button-row">
    <button class="btn" onclick="showKimchi()">
      <img src="Kimchi.png" alt="kimchi" />
      Kimchi
    </button>
    <button class="btn" onclick="showVodka()">üç∏ Vodka</button>
  </div>

<script>
/* ------------------------------------------------------------------ */
/* 1) CONFIG: point these at your files + frame counts                 */
/* ------------------------------------------------------------------ */
const SPRITES = {
  idle:  { src: 'NormalIdle.png', frames: 4, fw: 64, fh: 64, speed: 8 },
  eat:   { src: 'NormalEat.png',  frames: 6, fw: 64, fh: 64, speed: 8 },  // optional
  vodka: { src: 'Vodka.png',      frames: 6, fw: 64, fh: 64, speed: 8 }   // optional
};

// scale up so it‚Äôs not tiny (2 = 128px canvas drawn to 256 CSS px)
const SCALE = 2;

/* ------------------------------------------------------------------ */
/* 2) SETUP CANVAS (crisp pixels on HiDPI)                             */
/* ------------------------------------------------------------------ */
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');

(function setupScale(){
  const cssW = cvs.width * SCALE;
  const cssH = cvs.height * SCALE;
  const dpr = window.devicePixelRatio || 1;
  cvs.style.width  = cssW + 'px';
  cvs.style.height = cssH + 'px';
  cvs.width  = cssW * dpr;
  cvs.height = cssH * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);   // draw in CSS pixels
})();

/* ------------------------------------------------------------------ */
/* 3) SIMPLE ANIMATION STATE MACHINE                                   */
/* ------------------------------------------------------------------ */
let state = {
  key: 'idle',
  img: null,
  frames: 1,
  fw: 64, fh: 64,
  speed: 8,      // bigger = slower
  frame: 0,
  tick: 0,
  fallbackBurst: [] // sparkle/heart particles if we don‚Äôt have a sheet
};

function loadAnim(key){
  const def = SPRITES[key];
  state.key = key;
  state.frames = def.frames;
  state.fw = def.fw;
  state.fh = def.fh;
  state.speed = def.speed;
  state.frame = 0;
  state.tick = 0;
  state.fallbackBurst.length = 0;

  const img = new Image();
  img.onload = () => { state.img = img; };
  img.onerror = () => { state.img = null; }; // trigger fallback particles
  img.src = def.src;
}

/* ------------------------------------------------------------------ */
/* 4) DRAW LOOP                                                        */
/* ------------------------------------------------------------------ */
function loop(){
  requestAnimationFrame(loop);

  // clear
  ctx.clearRect(0,0,cvs.width, cvs.height);

  // center the sprite
  const drawW = state.fw * SCALE;
  const drawH = state.fh * SCALE;
  const x = (cvs.width / (window.devicePixelRatio||1) - drawW)/2;
  const y = (cvs.height/ (window.devicePixelRatio||1) - drawH)/2;

  if (state.img){
    // advance frame
    state.tick++;
    if (state.tick >= state.speed){
      state.tick = 0;
      state.frame = (state.frame + 1) % state.frames;
    }
    // source slice
    const sx = state.frame * state.fw;
    ctx.drawImage(state.img, sx, 0, state.fw, state.fh, x, y, drawW, drawH);
  } else {
    // Fallback: bounce the idle once + little particles
    drawFallbackIdle(x,y,drawW,drawH);
  }

  // particles (for ‚Äúhealed‚Äù / ‚Äúdrunk‚Äù effect)
  updateParticles();
  drawParticles();
}
requestAnimationFrame(loop);

/* ------------------------------------------------------------------ */
/* 5) BUTTON HANDLERS                                                  */
/* ------------------------------------------------------------------ */
function showIdle(){
  loadAnim('idle');
}

function showKimchi(){
  // try to use an eat animation; otherwise fallback with ‚Äúheal‚Äù particles
  if (imageExists(SPRITES.eat.src)){
    loadAnim('eat');
  } else {
    loadAnim('idle');
    spawnHealParticles();
  }
}

function showVodka(){
  if (imageExists(SPRITES.vodka.src)){
    loadAnim('vodka');
  } else {
    loadAnim('idle');
    spawnDrunkParticles();
  }
}

/* tiny helper: preflight check if file likely exists in repo path */
function imageExists(path){
  // We can‚Äôt fetch here due to GitHub CORS in some cases; instead,
  // attempt to load. If it 404s, onerror will set img=null and
  // our loop uses the fallback. This helper is only to decide which
  // animation key to pass to loadAnim; we‚Äôll just call loadAnim and
  // let onerror handle the rest.
  return true;
}

/* ------------------------------------------------------------------ */
/* 6) Fallback drawing & particles                                     */
/* ------------------------------------------------------------------ */
function drawFallbackIdle(x,y,w,h){
  // simple bob effect using a gray square (placeholder) if no image yet
  // You‚Äôll almost always have NormalIdle.png, so this path rarely runs.
  ctx.fillStyle = '#ccc';
  const bob = Math.sin(Date.now()/200)*2;
  ctx.fillRect(x, y + bob, w, h);
}

function spawnHealParticles(){
  // green + heart colors
  const cx = cvs.width/(window.devicePixelRatio||1)/2;
  const cy = cvs.height/(window.devicePixelRatio||1)/2 - 10;
  for (let i=0;i<10;i++){
    state.fallbackBurst.push({
      x: cx + (Math.random()*20-10),
      y: cy + (Math.random()*10-5),
      vx: (Math.random()*0.6-0.3),
      vy: - (1 + Math.random()*1.5),
      life: 40,
      color: i%2 ? '#e25590' : '#27ae60' // pink hearts & green heal
    });
  }
}

function spawnDrunkParticles(){
  // yellow ‚Äúsparkles‚Äù
  const cx = cvs.width/(window.devicePixelRatio||1)/2;
  const cy = cvs.height/(window.devicePixelRatio||1)/2 - 10;
  for (let i=0;i<12;i++){
    state.fallbackBurst.push({
      x: cx + (Math.random()*24-12),
      y: cy + (Math.random()*12-6),
      vx: (Math.random()*0.8-0.4),
      vy: - (0.6 + Math.random()*1.2),
      life: 36,
      color: '#f1c40f'
    });
  }
}

function updateParticles(){
  state.fallbackBurst.forEach(p=>{
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.04;   // gravity
    p.life--;
  });
  state.fallbackBurst = state.fallbackBurst.filter(p=>p.life>0);
}

function drawParticles(){
  state.fallbackBurst.forEach(p=>{
    ctx.fillStyle = p.color;
    ctx.fillRect(Math.round(p.x), Math.round(p.y), 3, 3);
  });
}

/* ------------------------------------------------------------------ */
/* 7) BOOT                                                             */
/* ------------------------------------------------------------------ */
loadAnim('idle'); // start with idle
</script>
</body>
</html>
